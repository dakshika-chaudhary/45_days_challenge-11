STEPS BY KNIGHT
code:
class Solution 
{
    public:
    
    bool isvalid(int i,int j,int n,vector<vector<bool>>&visited){
        return (i>=0 && i<n && j>=0 && j<n && !visited[i][j]);
    }
    //Function to find out minimum steps Knight needs to reach target position.
	int minStepToReachTarget(vector<int>&KnightPos,vector<int>&TargetPos,int N)
	{
	    int n=N;
	    int px=KnightPos[0]-1;  int py=KnightPos[1]-1;
	    int fx=TargetPos[0]-1;  int fy=TargetPos[1]-1;
	    
	    if(px==fx  &&  py==fy){return 0;}
	    vector<vector<bool>> visited(n, vector<bool>(n, false));
	    
	    queue<pair<pair<int,int>,int>>q;
	    q.push({{px,py},0});
	    visited[px][py]=true;
	    
	    while(!q.empty()){
	        auto p=q.front();
	       
	        q.pop();
	        
	        
	        int xx=p.first.first;
	        int yy=p.first.second;
	        int ans=p.second;
	        ans++;
	      
	        int ax[8]={1,1,-1,-1,2,-2,2,-2};
	        int ay[8]={2,-2,2,-2,1,1,-1,-1};
	        
	        for(int i=0;i<8;i++){
	            int nx=ax[i]+xx;
	            int ny=ay[i]+yy;
	            
	            if(isvalid(nx,ny,n,visited)){
	                
	                if(nx==fx && ny==fy){return ans;}
	                
	            q.push({{nx,ny},ans});
	            visited[nx][ny]=true;
	            }
	        }
	    }
	    
	    
	 return -1;
	
	}
};

SPIRAL MATRIX
code:
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>&v) {
       vector<int>vec;
int m = v.size();
int n = v[0].size();
        int minr=0;
        int maxr=m-1;

        int minc=0;
        int maxc=n-1;

        while(minr<=maxr && minc<=maxc){
            for(int j=minc;j<=maxc;j++){
              vec.push_back(v[minr][j]);}
               minr++;
               if(minr>maxr||minc>maxc){break;}
            
           for(int i=minr;i<=maxr;i++){
                vec.push_back(v[i][maxc]);}
                maxc--;
            if(minr>maxr||minc>maxc){break;}

          for(int j=maxc;j>=minc;j--){
                vec.push_back(v[maxr][j]);}
               maxr--;
            if(minr>maxr||minc>maxc){break;}

             for(int i=maxr;i>=minr;i--){
                vec.push_back(v[i][minc]);}
                minc++;
            if(minr>maxr||minc>maxc){break;}
        }
        
        return vec;
  }
};
