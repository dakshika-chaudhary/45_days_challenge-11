Delete nodes having greater value on right
code:
class Solution
{
    public:
    Node *compute(Node *head)
    
    {
        
         if (!head) return NULL;
        stack<Node*>st;
        Node*temp=head;
        st.push(temp);
        
        while(temp->next!=NULL){
            temp=temp->next;
            while (!st.empty() && st.top()->data < temp->data) {
                st.pop();
            }
            st.push(temp);
           
        }
        
        stack<Node*>at;
        while(!st.empty()){
          at.push(st.top());
          st.pop();
        }
        
        Node*c=new Node(0);
        Node*tempc=c;
        
        while(!at.empty()){
          tempc->next=new Node(at.top()->data);
          at.pop();
          tempc=tempc->next;
        }
        
        return c->next;
    }
    
};


Range sum of BST
code:
class Solution {
public:
int sum=0;
    int rangeSumBST(TreeNode* root, int low, int high) {
   if(root==NULL){return 0;}
       
    if(root->val>=low && root->val<=high){
    sum=sum+root->val;
    }
        
        rangeSumBST(root->left,low,high);
        rangeSumBST(root->right,low,high);
        
        return sum;
    }
};

SYMMETRIC TREE
code:
class Solution {
public:
    
    bool answer(TreeNode*t1,TreeNode*t2){
        if(t1==NULL && t2==NULL){return true;}
        if(t1==NULL || t2==NULL){return false;}
        if(t1->val!=t2->val){return false;} 
        
        return answer(t1->left,t2->right)&& answer(t1->right,t2->left);
    }
    
    bool isSymmetric(TreeNode* root) {
     if(root==NULL){return true;}
       
        
       return answer(root,root); 
    }
};
   
